# Azure Administrator 

1. Use PowerShell to Resize an Azure Virtual Machine in an Availability Set

```powershell
Get-AzVM
Get-AzSubscription
az monitor metrics list --resource /subscriptions/<ID>/resourceGroups/<RESOURCE_GROUP_NAME>/providers/Microsoft.Compute/virtualMachines/labVM0
$vm = Get-AzVM -ResourceGroupName <RESOURCE_GROUP_NAME> -VMName labVM0
$vm.HardwareProfile.VmSize = "Standard_B1s"
Update-AzVM -VM $vm -ResourceGroupName <RESOURCE_GROUP_NAME>
```


2. Install NGINX on a Linux VM in Deployment with Cloud Init

cloud-init script:
```
#cloud-config
packages_upgrade: true
packages:
  - nginx
```

Checking if NGINX is running on vm
```bash
nginx -v
sudo systemctl status nginx
```


3. Snapshot an Azure VM Disk using PowerShell

perform powershell operations
```powershell
$rg = "<RESOURCE_GROUP_NAME>"
$diskname = "<VIRTUAL_MACHINE_DISK_NAME>"
$sasExpiryDuration = "3600"
$storageAccountName = "<STORAGE_ACCOUNT_NAME>"
$storageAccountKey = "<KEY1_STORAGE_ACCOUNT_KEY>"

# new additional vars
$storageContainerName = "container1"
$destinationVHDFileName = "disk1.vhd"
$useAzCopy = 1
$vmName = "winVM"

Stop-AzVM -ResourceGroupName $rg -Name $vmName
```

Take a Snapshot of the VM
```powershell
$sas = Grant-AzDiskAccess -ResourceGroupName $rg -DiskName $diskName -DurationInSecond $sasExpiryDuration -Access Read
$destinationContext = New-AzStorageContext -StorageAccountName $storageAccountName -StorageAccountKey $storageAccountKey

if($useAzCopy -eq 1)
{
$containerSASURI = New-AzStorageContainerSASToken -Context $destinationContext -ExpiryTime(get-date).AddSeconds($sasExpiryDuration) -FullUri -Name $storageContainerName -Permission rw
azcopy copy $sas.AccessSAS $containerSASURI

}else{

Start-AzStorageBlobCopy -AbsoluteUri $sas.AccessSAS -DestContainer $storageContainerName -DestContext $destinationContext -DestBlob $destinationVHDFileName
}
```


4. Using Custom Images for a Virtual Machine Scale Set in Azure
  Create an image gallery.
  Create an image definition.
  Create an image version.
```bash
RG="<RESOURCE_GROUP_NAME>"
IMAGE="<RESOURCE_ID>"
az sig create --resource-group $RG --location westus --gallery-name imageGallery

az sig image-definition create \
--resource-group $RG \
--location westus \
--gallery-name imageGallery \
--gallery-image-definition imageDefinition \
--publisher acg \
--offer ubuntu \
--sku Ubuntu-1804 \
--os-type Linux \
--os-state specialized

az sig image-version create \
--resource-group $RG \
--location westus \
--gallery-name imageGallery \
--gallery-image-definition imageDefinition \
--gallery-image-version 1.0.0 \
--target-regions "westus=1" "eastus=1" \
--managed-image $IMAGE

# creating vm scale set from image, use image def resource id
az vmss create \
--resource-group $RG \
--name myVmss \
--image "<RESOURCE_ID>" \
--specialized \
--generate-ssh-key \
--location westus
```


5. Create a Standard Load Balancer with Azure CLI
```
RG="<RESOURCE_GROUP_NAME>"
LOC="<REGION>"
NSG="<NETWORK_SECURITY_GROUP_NAME>"
VNET="<VNET_NAME>"
SNET="default"

# create network interface for vm
az network nic create \
--resource-group $RG \
--location $LOC \
--name myNicVM1 \
--vnet-name $VNET \
--subnet $SNET \
--network-security-group $NSG

# NIC for 2nd vm
az network nic create \
--resource-group $RG \
--location $LOC \
--name myNicVM2 \
--vnet-name $VNET \
--subnet $SNET \
--network-security-group $NSG

az vm create \
--resource-group $RG \
--location $LOC \
--name myVM1 \
--nics myNicVM1 \
--image UbuntuLTS \
--generate-ssh-keys \
--custom-data cloud-init.txt \
--zone 1 \
--no-wait

az vm create \
--resource-group $RG \
--location $LOC \
--name myVM2 \
--nics myNicVM2 \
--image UbuntuLTS \
--generate-ssh-keys \
--custom-data cloud-init.txt \
--zone 2 \
--no-wait

az network public-ip create \
--resource-group $RG \
--location $LOC \
--name myPublicIP \
--sku Standard

az network lb create \
--resource-group $RG \
--location $LOC \
--name myLoadBalancer \
--sku Standard \
--public-ip-address myPublicIP \
--frontend-ip-name myFrontEnd \
--backend-pool-name myBackEndPool

az network lb probe create \
--resource-group $RG \
--lb-name myLoadBalancer \
--name myHealthProbe \
--protocol tcp \
--port 80

az network lb rule create \
--resource-group $RG \
--lb-name myLoadBalancer \
--name myHTTPRule \
--protocol tcp \
--frontend-port 80 \
--backend-port 80 \
--frontend-ip-name myFrontEnd \
--backend-pool-name myBackEndPool \
--probe-name myHealthProbe \
--disable-outbound-snat true

az network nic ip-config address-pool add \
--address-pool myBackEndPool \
--ip-config-name ipconfig1 \
--nic-name myNicVM1 \
--resource-group $RG \
--lb-name myLoadBalancer

az network nic ip-config address-pool add \
--address-pool myBackEndPool \
--ip-config-name ipconfig1 \
--nic-name myNicVM2 \
--resource-group $RG \
--lb-name myLoadBalancer

az network public-ip show \
--resource-group $RG \
--name myPublicIP \
--query [ipAddress] \
--output tsv
```

cloud init config file for vms
```
#cloud-config
package_upgrade: true
packages:
  - nginx
  - nodejs
  - npm
write_files:
  - owner: www-data:www-data
  - path: /etc/nginx/sites-available/default
    content: |
      server {
        listen 80;
        location / {
          proxy_pass http://localhost:3000;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection keep-alive;
          proxy_set_header Host $host;
          proxy_cache_bypass $http_upgrade;
        }
      }
  - owner: azureuser:azureuser
  - path: /home/azureuser/myapp/index.js
    content: |
      var express = require('express')
      var app = express()
      var os = require('os');
      app.get('/', function (req, res) {
        res.send('Hello World from host ' + os.hostname() + '!')
      })
      app.listen(3000, function () {
        console.log('Hello world app listening on port 3000!')
      })
runcmd:
  - service nginx restart
  - cd "/home/azureuser/myapp"
  - npm init
  - npm install express -y
  - nodejs index.js
```

Build and Run a Container Using Azure ACR Tasks

```bash
# Create a New Container Registry
az acr create --resource-group <RESOURCE_GROUP_NAME> \
--name acrbuildcontainer11 --sku Basic --admin-enabled true

# create docker file
echo "FROM hello-world" > Dockerfile

# Build an Image and Push to ACR
az acr build --image sample/hello-world:v1 --registry acrbuildcontainer11 \
--file Dockerfile .

# Run the New Container
az acr run --registry acrbuildcontainer11 --cmd '$Registry/sample/hello-world:v1' /dev/null
```
